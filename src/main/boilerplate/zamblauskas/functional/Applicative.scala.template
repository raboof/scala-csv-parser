package zamblauskas.functional

trait Applicative[F[_]] extends Functor[F]:
  def unit[A](a: A): F[A]
  extension [A](fa: F[A]) def apply[B](f: F[A => B]): F[B]

  // derived methods
  extension [A](fa: F[A]) def map[B](f: A => B): F[B] = apply(fa)(unit(f))

  extension [A](fa: F[A]) def map1[B](f: A => B): F[B] = map(fa)(f)

  [1..21#extension [[#P1#], P2](fa: ([#F[P1]#], F[P2])) def map2[R](f: ([#P1#], P2) => R): F[R] =
    apply(fa._2)(map1([#fa._1#])(([#p1#]) => f.curried [#(p1)# ]))  #
  ]

[2..21#trait ApplicativeBuilder1[F[_], [#P1#]] { self =>
  [#val p1: F[P1]#
  ]

  def apply[R](f: ([#P1#]) => R)(implicit ap: Applicative[F]): F[R] = ap.map1([#p1#])(f)

  def and[R](r: F[R]): ApplicativeBuilder2[F, [#P1#], R] = new ApplicativeBuilder2[F, [#P1#], R]:
    [#val p1: F[P1] = self.p1#
    ]
    val p2: F[R] = r
}#
]

[22..22#trait ApplicativeBuilder1[F[_], [#P1#]] { self =>
  [#val p1: F[P1]#
  ]

  def apply[R](f: ([#P1#]) => R)(implicit ap: Applicative[F]): F[R] = ap.map1([#p1#])(f)
}#
]

extension [F[_], P1](fa: F[P1])
  def and[P2](r: F[P2]): ApplicativeBuilder2[F, P1, P2] = new ApplicativeBuilder2[F, P1, P2]:
    val p1: F[P1] = fa
    val p2: F[P2] = r
